{"version":3,"sources":["page-headers.ts","PageBlocks.tsx","packages/scroll-spy/scroll-window.ts","packages/scroll-spy/notification.ts","packages/scroll-spy/intersection-observer.ts","packages/scroll-spy/create-scroll-spy.ts","SideNavMenuItem.tsx","packages/scroll-spy/react.ts","SideNav.tsx","App.tsx","globalStyles.ts","index.tsx"],"names":["createHeader","title","level","slug","slugify","lower","remove","pageHeaders","installation","props","theme","cssProp","media","conclusion","PageBlocks","column","gap","headerKey","Block","component","Div","as","id","StyledBox","height","styled","FlexBox","attrs","center","div","ScrollWindow","idActiveMap","currentActiveId","undefined","blindSpotId","this","isActive","checkBlindSpot","keyValues","Object","entries","idx","length","Notifier","handler","previousValue","currentValue","value","Notification","notifierMap","update","values","forEach","notifier","notify","IntersectionObserver","window","createScrollSpy","options","refList","scrollWindow","notification","observer","entry","element","matches","getSelector","target","isIntersecting","reset","currentActive","getActive","flush","observe","url","push","add","document","querySelector","onIntersectionChange","fn","for","clean","disconnect","useScrollSpy","useState","setActive","useEffect","createScrollSpyFactory","root","MenuItem","Item","onClick","e","preventDefault","header","scrollIntoView","behavior","href","a","SideNav","Aside","aside","Main","main","App","GlobalStyles","createGlobalStyle","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.5e6da146.chunk.js","sourcesContent":["import slugify from 'slugify';\r\n\r\nfunction createHeader(title: string, level: number) {\r\n  return {\r\n    title,\r\n    level,\r\n    slug: slugify(title, {\r\n      lower: true,\r\n      remove: /[\\d.]/,\r\n    }),\r\n  };\r\n}\r\n\r\nexport type PageHeaderKind = keyof typeof pageHeaders;\r\n\r\nexport const pageHeaders = {\r\n  title: createHeader('Styled Components & TypeScript', 1),\r\n  installation: createHeader('1. Installing the types', 2),\r\n  props: createHeader('2. Custom props', 2),\r\n  theme: createHeader('3. Typing the theme', 2),\r\n  cssProp: createHeader('3.1. Making use of css prop', 3),\r\n  media: createHeader('3.2. Media templates', 3),\r\n  conclusion: createHeader('4. Conclusion', 2),\r\n} as const;\r\n","import { FlexBox } from 'react-styled-flex';\r\nimport styled from 'styled-components';\r\nimport { PageHeaderKind, pageHeaders } from './page-headers';\r\n\r\nexport const PageBlocks = () => {\r\n  return (\r\n    <FlexBox column gap={'2rem'}>\r\n      <Block headerKey={'title'} />\r\n      <Block headerKey={'installation'} />\r\n      <Block headerKey={'props'} />\r\n      <Block headerKey={'theme'} />\r\n      <Block headerKey={'cssProp'} />\r\n      <Block headerKey={'media'} />\r\n      <Block headerKey={'conclusion'} />\r\n    </FlexBox>\r\n  );\r\n};\r\n\r\nconst Block = ({ headerKey }: { headerKey: PageHeaderKind }) => {\r\n  const { title, slug, level } = pageHeaders[headerKey];\r\n  const component = `h${level}`;\r\n\r\n  return (\r\n    <>\r\n      {/* @ts-expect-error */}\r\n      <Div as={component} id={slug}>\r\n        {title}\r\n      </Div>\r\n      <StyledBox height={'1200px'}>Paragraph</StyledBox>\r\n    </>\r\n  );\r\n};\r\n\r\nconst StyledBox = styled(FlexBox).attrs({ as: 'section', center: true })`\r\n  background-color: #f1f1f1;\r\n`;\r\n\r\nconst Div = styled.div``;\r\n","/**\r\n * Intersection observer can return multiple entries as active.\r\n * ScrollWindow maintains list map of id and their active status\r\n * Also it returns first active on the screen, even if there are blindSpots developed\r\n */\r\n\r\nexport class ScrollWindow {\r\n  idActiveMap: Record<string, boolean> = {};\r\n  currentActiveId: string | undefined = undefined;\r\n  blindSpotId: string | undefined = undefined;\r\n\r\n  /*\r\n    register id in underlying map, initial value will be false\r\n  */\r\n  add(id: string) {\r\n    this.idActiveMap[id] = false;\r\n  }\r\n\r\n  /*\r\n    update isActive status of relevant id\r\n  */\r\n  update(id: string, isActive: boolean) {\r\n    this.idActiveMap[id] = isActive;\r\n    this.checkBlindSpot(id);\r\n  }\r\n\r\n  /**\r\n   * get first active id, if one is not available then blindSpotting is activated\r\n   */\r\n  getActive() {\r\n    const keyValues = Object.entries(this.idActiveMap);\r\n    for (let idx = 0; idx < keyValues.length; idx++) {\r\n      const [id, isActive] = keyValues[idx];\r\n      if (isActive) {\r\n        this.currentActiveId = id;\r\n        return id;\r\n      }\r\n    }\r\n\r\n    /* \r\n            if code has reached here, definitely a blindSpot is developed\r\n            now proceed only if currentActive is available \r\n        */\r\n    if (!this.currentActiveId) return;\r\n\r\n    /* now revert the changes */\r\n    this.idActiveMap[this.currentActiveId] = true;\r\n\r\n    /* activate blindSpot */\r\n    this.blindSpotId = this.currentActiveId;\r\n    return this.currentActiveId;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * check if blindSpot activated\r\n   */\r\n  private checkBlindSpot(id: string) {\r\n    /* early bailout if no active blindSpot */\r\n    if (!this.blindSpotId) return;\r\n\r\n    if (id === this.blindSpotId) {\r\n      /* current active and blindSpot are same, no need to do anything */\r\n    } else {\r\n      /* otherwise, make blindSpot in-active */\r\n      this.idActiveMap[this.blindSpotId] = false;\r\n    }\r\n\r\n    /* de-activate blindSpot */\r\n    this.blindSpotId = undefined;\r\n  }\r\n\r\n  /**\r\n   * clean all underlying data structures\r\n   */\r\n  clean() {\r\n    this.idActiveMap = {};\r\n    this.currentActiveId = undefined;\r\n    this.blindSpotId = undefined;\r\n  }\r\n}\r\n","type Handler = (value: boolean) => void;\r\n\r\nclass Notifier {\r\n  handler: Handler;\r\n  previousValue: boolean | undefined;\r\n  currentValue: boolean;\r\n\r\n  constructor(handler: Handler) {\r\n    this.handler = handler;\r\n    this.previousValue = undefined;\r\n    this.currentValue = false;\r\n  }\r\n\r\n  update(value: boolean) {\r\n    this.previousValue = this.currentValue;\r\n    this.currentValue = value;\r\n  }\r\n\r\n  notify() {\r\n    if (this.previousValue !== this.currentValue) {\r\n      this.handler(this.currentValue);\r\n    }\r\n  }\r\n}\r\n\r\nexport class Notification {\r\n  notifierMap: Record<string, Notifier> = {};\r\n\r\n  /* register notifier for given id */\r\n  for(id: string, handler: Handler) {\r\n    this.notifierMap[id] = new Notifier(handler);\r\n  }\r\n\r\n  update(id: string, value: boolean) {\r\n    const notifier = this.notifierMap[id];\r\n    notifier.update(value);\r\n  }\r\n\r\n  reset() {\r\n    Object.values(this.notifierMap).forEach((notifier) =>\r\n      notifier.update(false),\r\n    );\r\n  }\r\n\r\n  flush() {\r\n    Object.values(this.notifierMap).forEach((notifier) => notifier.notify());\r\n  }\r\n\r\n  clean() {\r\n    this.notifierMap = {};\r\n  }\r\n}\r\n","/**\r\n * exporting instance of IntersectionObserver if window is defined, in case of browser execution\r\n * otherwise return dummy IntersectionObserver function with needed functions\r\n * This is done to support SSR\r\n */\r\n\r\nexport const IntersectionObserver = (() => {\r\n  if (typeof window === 'undefined') {\r\n    return class {\r\n      observe() {}\r\n      disconnect() {}\r\n    };\r\n  } else {\r\n    return window.IntersectionObserver;\r\n  }\r\n})();\r\n","import { ScrollWindow } from './scroll-window';\r\nimport { Notification } from './notification';\r\nimport { IntersectionObserver } from './intersection-observer';\r\n\r\n/**\r\n * createScrollSpy is hook-factory which returns useScrollSpy hook and cleanup functions\r\n */\r\n\r\nexport const createScrollSpy = (options: IntersectionObserverInit) => {\r\n  /* create getSelector utility */\r\n  const refList: string[] = [];\r\n  const getSelector = (element: Element) => {\r\n    for (let idx = 0; idx < refList.length; idx++) {\r\n      if (element.matches(refList[idx])) return refList[idx];\r\n    }\r\n  };\r\n\r\n  /* create scrollWindow and notification instances */\r\n  const scrollWindow = new ScrollWindow();\r\n  const notification = new Notification();\r\n\r\n  /* create intersection observer instance */\r\n  const observer = new IntersectionObserver((entries) => {\r\n    /* update scrollWindow with new entries */\r\n    entries.forEach((entry) => {\r\n      const id = getSelector(entry.target);\r\n      id && scrollWindow.update(id, entry.isIntersecting);\r\n    });\r\n\r\n    /* reset notification */\r\n    notification.reset();\r\n\r\n    /* get active id from scroll window and update notification */\r\n    const currentActive = scrollWindow.getActive();\r\n    currentActive && notification.update(currentActive, true);\r\n\r\n    /* flush all notifications */\r\n    notification.flush();\r\n  }, options);\r\n\r\n  return {\r\n    /* add url to local refList, scrollWindow and observe */\r\n    observe(url: string) {\r\n      refList.push(url);\r\n      scrollWindow.add(url);\r\n\r\n      const element = document.querySelector(url);\r\n      element && observer.observe(element);\r\n    },\r\n\r\n    /* on intersection change for element */\r\n    onIntersectionChange(url: string, fn: (isActive: boolean) => void) {\r\n      notification.for(url, (isActive) => fn(isActive));\r\n    },\r\n\r\n    /* cleanup function */\r\n    clean() {\r\n      observer.disconnect();\r\n      scrollWindow.clean();\r\n      notification.clean();\r\n    },\r\n  };\r\n};\r\n\r\n/*\r\nTwo reasons why implementing scrollSpy using intersection observer is a bad idea\r\n\r\n1. What if two adjacent sections has large gap between them ? We should use intersectionRatios as compared to isIntersecting\r\n2. What if two headers have same ids ? Use of intersection observer is based on configuring correct unique ids.\r\n\r\n*/\r\n","import React from 'react';\r\nimport { PageHeaderKind, pageHeaders } from './page-headers';\r\nimport styled from 'styled-components';\r\nimport { createScrollSpyFactory } from './packages';\r\n\r\nconst useScrollSpy = createScrollSpyFactory({\r\n  root: document,\r\n});\r\n\r\nexport const MenuItem = ({ headerKey }: { headerKey: PageHeaderKind }) => {\r\n  const { title, slug, level } = pageHeaders[headerKey];\r\n  const isActive = !!useScrollSpy(`#${slug}`);\r\n  const onLinkClick = (e: React.MouseEvent<HTMLAnchorElement>) => {\r\n    e.preventDefault();\r\n\r\n    const header = document.querySelector(`#${slug}`);\r\n    header?.scrollIntoView({ behavior: 'smooth' });\r\n  };\r\n\r\n  return (\r\n    <Item\r\n      onClick={onLinkClick}\r\n      href={`#${slug}`}\r\n      level={level}\r\n      isActive={isActive}\r\n    >\r\n      {title}\r\n    </Item>\r\n  );\r\n};\r\n\r\nconst Item = styled.a<{ level: number; isActive: boolean }>`\r\n  display: inline-block;\r\n  margin: 0.4rem;\r\n  list-style-type: none;\r\n  margin-left: ${(props) => props.level}rem;\r\n  font-weight: ${(props) => (props.isActive ? 'bold' : '')};\r\n  color: ${(props) => (props.isActive ? '#fff' : '#eee')};\r\n  text-decoration: none;\r\n`;\r\n","import { useEffect, useState } from 'react';\r\nimport { createScrollSpy } from './create-scroll-spy';\r\n\r\nexport const createScrollSpyFactory = (options: IntersectionObserverInit) => {\r\n  const { observe, onIntersectionChange, clean } = createScrollSpy(options);\r\n\r\n  return (url: string) => {\r\n    const [isActive, setActive] = useState(false);\r\n\r\n    useEffect(() => {\r\n      observe(url);\r\n\r\n      onIntersectionChange(url, (isActive: boolean) => setActive(isActive));\r\n      return () => clean();\r\n    }, [url]);\r\n\r\n    return isActive;\r\n  };\r\n};\r\n","import styled from 'styled-components';\r\nimport { MenuItem } from './SideNavMenuItem';\r\n\r\nexport const SideNav = () => {\r\n  return (\r\n    <Aside>\r\n      <nav>\r\n        <ul>\r\n          <MenuItem headerKey={'title'} />\r\n          <MenuItem headerKey={'installation'} />\r\n          <MenuItem headerKey={'props'} />\r\n          <MenuItem headerKey={'theme'} />\r\n          <MenuItem headerKey={'cssProp'} />\r\n          <MenuItem headerKey={'media'} />\r\n          <MenuItem headerKey={'conclusion'} />\r\n        </ul>\r\n      </nav>\r\n    </Aside>\r\n  );\r\n};\r\n\r\nconst Aside = styled.aside`\r\n  position: sticky;\r\n  top: 2rem;\r\n  height: calc(100vh - 4rem);\r\n  background-color: #0057d9;\r\n  color: #fff;\r\n\r\n  ul {\r\n    padding: 0;\r\n    padding: 2rem 1rem;\r\n  }\r\n`;\r\n","import styled from 'styled-components';\nimport { PageBlocks } from './PageBlocks';\nimport { SideNav } from './SideNav';\n\nfunction App() {\n  return (\n    <Main>\n      <SideNav />\n      <PageBlocks />\n    </Main>\n  );\n}\n\nconst Main = styled.main`\n  display: grid;\n  grid-template-columns: minmax(200px, 30%) auto;\n  gap: 2rem;\n  max-width: 1200px;\n  margin: auto;\n  padding: 2rem;\n`;\n\nexport default App;\n","import { createGlobalStyle } from 'styled-components';\r\n\r\nexport const GlobalStyles = createGlobalStyle`\r\n    html {    \r\n        font-family: system-ui;\r\n    }\r\n    \r\n    *,\r\n    *::before,\r\n    *::after {\r\n        margin: 0;    \r\n        box-sizing: border-box;\r\n    }\r\n`;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { GlobalStyles } from './globalStyles';\n\nReactDOM.render(\n  <React.StrictMode>\n    <GlobalStyles />\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}